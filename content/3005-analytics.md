---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.7
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
mystnb:
  execution_mode: inline

---

# Analytics

```{code-cell} ipython3
:tags: [hide-cell]

import json
import pathlib
import warnings
from pathlib import Path
from datetime import datetime

import altair as alt
import numpy as np

import pandas as pd
from altair.vegalite.v4.display import html_renderer, svg_renderer
from IPython.display import Code

warnings.filterwarnings("ignore")


# Embed more MIME bundles into the rendered output
def many_mime_renderer(spec):
    bundle = {}
    metadata = {}
    bundle["text/plain"] = "<VegaLite 4 object>"
    bundle["application/vnd.vegalite.v4+json"] = spec
    bundle.update(html_renderer(spec))
    bundle.update(svg_renderer(spec))
    return bundle, metadata


alt.renderers.register("many_mime", many_mime_renderer)
alt.renderers.enable("many_mime");
```

## User Analytics

+++

In order to provision appropriate resources for the Kubernetes JupyterHub deployment such that costs could be minimised, a number of metrics were recorded. These data were then parsed from the Google Cloud Logging backend, and built into a dataset consisting of JSON records. Each record was built by correlating analytics events, e.g. the adjacent start and stop events for a particular user server. These records were then aggregated by notebook path (experiment name), time (concurrent users), and analysed to give indications towards usage trends.

+++

The produced JSON records consisted of two families: a notebook record (see {numref}`output:notebook-record`), and a server record (see {numref}`output:server-record`). Both records contain a user ID field which uniquely identifies the user to whom the record pertains. The server record includes only the start and stop times of the server.

+++

:::{code-block} yaml
:caption:  An example server-session record taken from recorded analytics.
:name: output:server-record

{
    "user": "5ac27e656c88c5cddd3ebe956b57819586541a810ffac363eab2906e0539d6db",
    "start": 1605711173,
    "start_delay": 2.231,
    "stop": 1605717001,
    "stop_delay": 6.851
}
:::

```{code-cell} ipython3
:tags: [hide-cell]

data_dir = pathlib.Path("olab-analytics", "server-sessions")
sessions = [json.loads(p.read_text()) for p in data_dir.glob("*.json")]

df = pd.DataFrame(sessions)
df["start"] = pd.to_datetime(df["start"], unit="s")
df["stop"] = pd.to_datetime(df["stop"], unit="s")
df["duration_minutes"] = (df["stop"] - df["start"]).dt.total_seconds() / 60
df.head()
```

```{code-cell} ipython3
:tags: [remove-input, remove-output]

# Bind the start timestamp to the user, resample series to days, find the unique users per sample and reset
daily_active_users = pd.DataFrame(
    df.set_index("start")["user"].resample("D").nunique()
).reset_index()

is_weekday = (daily_active_users.start.dt.day_of_week != 5) & (
    daily_active_users.start.dt.day_of_week != 6
)
is_early_dec = (daily_active_users.start.dt.month == 12) & (
    (daily_active_users.start.dt.day < 14)
)
daily_active_users.loc[is_weekday, "user"].describe().T
```

The `start` time of each user server was downsampled to a granularity of days, and the distinct number of unique users per-day computed. A total of {eval}`len(np.unique(df.user))` unique users (including demonstrators) were identified in this dataset. See {numref}`table:olab-unique-users` for a subset of these records. The OLAB cluster was closed over the weekend to minimise running costs, which is reflected in the sharp, constant drop in users during these two-day windows. The median number of concurrent users for the entire trial period was found to be {eval}`int(daily_active_users.loc[is_weekday, "user"].median())` users per day, but this value represents the entire distribution; in totality, the trial was phased as different student cohorts were given access to the resource. Throughout the month of November, a steady increasing trend in the number of concurrent users can be seen. In the subsequent period, user engagement remained fairly closely distributed around {eval}`int(daily_active_users.loc[is_weekday & is_early_dec, "user"].median())` daily users. Strongly evident in these data is the end of term on the 21st of December 2020; in the week preceding, student engagement was much reduced.

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The unique number of OLAB users aggregated by day. Anonymous user IDs
      were generated by hashing the unique Canvas student IDs.
    name: table:olab-unique-users
tags: [hide-input]
---
alt.Chart(daily_active_users).mark_line(interpolate="step-after").encode(
    x="start", y="user"
).interactive()
```

```{code-cell} ipython3
:tags: [remove-input, remove-output]

user_starts_count = df.groupby("user").count()["start"].to_frame()
user_starts_count.describe().T
```

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The number of times each user started a server. Anonymous user IDs were
      generated by hashing the unique Canvas student IDs.
    name: table:olab-user-starts
tags: [hide-input]
---
alt.Chart(user_starts_count).mark_bar().encode(
    alt.X("start", bin=alt.BinParams(step=1.0)), y="count()"
).interactive()
```

On a per-user basis, a long-tailed distribution was observed in the number of times that a server session was started (see {numref}`table:olab-user-starts`). The first quartile of the number of starts was found to be {eval}`int(user_starts_count.quantile(0.25))`. The cumulative session duration of each user shown in {numref}`chart:olab-cum-session-duration` indicates that the majority of these single-use servers were opened for very short periods of time. Meanwhile, {numref}`chart:olab-start-stop-sessions` shows that the start times of each user session are skewed earlier in the single-use server dataset. This is likely due to the following phenomena:
- demonstrators walking through the login process with students; these demonstrators were not required to use OLAB during the sessions.
- servers that failed to launch for particular users.
- students from outside the teaching cohort visiting the deployment page.
- students failing to meaningfully engage with the laboratory.

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The start times for each user session, grouped according to whether the
      user started more than one session during the trial.
    name: chart:olab-start-stop-sessions
tags: [hide-input]
---
user_started_once = user_starts_count.index[user_starts_count.start == 1]
df.loc[:, "is_single_use"] = df.user.isin(user_started_once)
alt.Chart(df).mark_tick().encode(
    x="start",
    y="is_single_use:N",
).interactive()
```

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The total session duration of each user.
    name: chart:olab-cum-session-duration
tags: [hide-input]
---
df_by_user = df.loc[:, ["duration_minutes", "user"]].groupby("user").sum()
df_by_user.loc[:, "count"] = df.groupby("user").start.count()

# Cutoff for extreme outliers
df_by_user_started = df_by_user
df_by_user_started["is_single_use"] = df_by_user_started.loc[:, "count"] == 1

alt.Chart(df_by_user_started).mark_bar().encode(
    alt.X("duration_minutes", bin=alt.BinParams(step=30.0)),
    y=alt.Y("count()"),
    color="is_single_use:N",
).interactive()
```

+++ {"jp-MarkdownHeadingCollapsed": true}

The median session length for single-use servers was found to be {eval}`f"{df_by_user_started.loc[df_by_user_started.is_single_use].duration_minutes.median():.2f} minutes"`. This includes an additional margin of one minute for the server to detect and stop servers after users close the browser tab. Due to the anonymisation of records, it is not possible to isolate instructors from students in these data. The median session length across all server sessions was {eval}`f"{df_by_user_started.duration_minutes.quantile(0.5):.1f} min"`, with a long tailed distribution; the mean session length was {eval}`f"{df_by_user_started.duration_minutes.mean():.1f} min"` with a standard deviation of {eval}`f"{df_by_user_started.duration_minutes.std():.1f} min"`. One reason for this long-tail is the possibility of idle servers; servers with which users are no longer interacting, but remain open and consuming resources. A prompt was generated to remind users to close unused servers, but the component responsible for automatically closing the server (after a grace period elapsed) was not successful, following some technical problems with API authentication.

```{code-cell} ipython3
:tags: [remove-cell]

df["duration_minutes"].describe()
```

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The duration of each started user server.
    name: chart:olab-session-duration
tags: [hide-input]
---
duration_cutoff = df.duration_minutes.quantile(0.99)

alt.Chart(df.loc[df["duration_minutes"] < duration_cutoff]).mark_bar().encode(
    alt.X("duration_minutes", bin=alt.BinParams(maxbins=30)), y="count()"
).interactive()
```

```{code-cell} ipython3
:tags: [remove-input, remove-output]

server_events = df.melt(
    var_name="event", value_name="time", value_vars=["start", "stop"]
).sort_values("time")
concurrent = server_events.event.map({"start": 1, "stop": -1}).cumsum()
sessions = server_events.assign(concurrent=concurrent)

sessions.describe()
```

```{code-cell} ipython3
:tags: [remove-output, remove-input]

is_before_nov = sessions.time < datetime(2020, 11, 8)
is_before_dec = sessions.time < datetime(2020, 12, 8)
sessions.loc[is_before_nov].describe()
```

```{code-cell} ipython3
:tags: [remove-cell]

sessions.loc[(~is_before_nov) & is_before_dec].describe()
```

To better understand resource provision, it is useful to look at the number of concurrent users over the course of the trial (see {numref}`chart:olab-concurrent-users`). From a peak of {eval}`sessions.concurrent.max()` users, the median number of concurrent users was {eval}`round(sessions.concurrent.median())`. Again, partitioning the dataset around the 9th of November reveals two trends; the median number of concurrent sessions in the pre-November period was {eval}`int(sessions.loc[is_before_nov].median())`, whilst during the second period this value was {eval}`int(sessions.loc[(~is_before_nov) & is_before_dec].median())`. This finding was significantly far from early predictions; to ensure sufficient capacity exists for 90% of the trial period, provision for only {eval}`int(np.ceil(sessions[(~is_before_nov) & is_before_dec].concurrent.quantile(0.9)))` concurrent users was required. With the near-continuous roll-out of OLAB within the separate student cohorts, and without the necessary further study into usage trends and student engagement, only limited conclusions can be drawn from these data. Specifically, it is not within scope to use these data in order to predict the capacity required for future deployments.

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The number of concurrent users (users whose `start` and `end` times overlap).
    name: chart:olab-concurrent-users
tags: [hide-input]
---
(
    alt.Chart(sessions)
    .mark_line(interpolate="step-after")
    .encode(x="time", y="concurrent")
    .interactive()
)
```

## Notebook Analytics

+++

The notebook record includes information about the time that a notebook session started, stopped, and to which notebook the record corresponds (see {numref}`output:notebook-record`).

+++

:::{code-block} yaml
:caption:  An example notebook-session record taken from recorded analytics.
:name: output:notebook-record

{
    "user": "62a39aa76ab34147ef996f9f8f052dd663d67b38bf13c55e8ce6b911404b2e8e",
    "kernel_id": "a5f751d0-1650-480a-b5b6-3384f6f72c96",
    "start": 1605878281,
    "notebook": "index.ipynb",
    "stop": 1605878396
}
:::

```{code-cell} ipython3
:tags: [hide-cell]

data_dir = pathlib.Path("olab-analytics", "notebook-sessions")

sessions = [json.loads(p.read_text()) for p in data_dir.glob("*.json")]

df = pd.DataFrame(sessions)
df["start"] = pd.to_datetime(df["start"], unit="s")
df["stop"] = pd.to_datetime(df["stop"], unit="s")
df["duration_seconds"] = (df["stop"] - df["start"]).dt.total_seconds()
df.head()
```

Within the notebook analytics, clear trends emerge with respect to access patterns. In {numref}`chart:olab-noteobook-access-patterns`, a timeline plot of the per-notebook session intervals is shown. It can clearly be seen that the `30-gamma-attenuation.ipynb` resource was accessed predominantly after the 13th of November. Meanwhile, students most-frequently visited the `10-nai-detector.ipynb` NaI(Tl) detector investigation notebook throughout the trial, with similar degree of regularity to that of the HPGe detector investigation notebook. It is likely that these notebooks were used as a reference on detector behaviour and principles (e.g. solid angle calculations) even after students had completed the experiment in the early (relative) weeks of the trial.

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: Experiment notebook access patterns during the trial.
    name: chart:olab-noteobook-access-patterns
tags: [hide-input]
---
alt.Chart(df).mark_bar().encode(x="start", x2="stop", y="notebook").interactive()
```

```{code-cell} ipython3
:tags: [remove-output, remove-input]

df_count_by_user = (
    df.loc[df.notebook != "index.ipynb"].groupby("user").count().reset_index()
)
df_unique_count_by_user = (
    df.loc[df.notebook != "index.ipynb"]
    .groupby("user")["notebook"]
    .nunique()
    .reset_index()
)
df_unique_count_by_notebook = df.groupby("notebook").nunique().reset_index()
```

```{code-cell} ipython3
:tags: [remove-cell]

df_unique_count_by_user.describe()
```

The number of times a notebook server was launched differed significantly across users. {numref}`chart:olab-notebook-sessions` shows the distribution of the number of started notebooks across the trial participants. A significant number of users opened under two notebook sessions, with the median number of notebook sessions equal to {eval}`int(df_count_by_user.notebook.median())` sessions per user. Within these sessions, it is useful to consider the unique notebooks that were opened by each user. {numref}`chart:olab-unique-notebook-sessions` plots the distribution of the number of unique notebooks opened by users. It is clear that the median student opened {eval}`int(df_unique_count_by_user.notebook.median())` notebooks. A breakdown of the number of users that visited each notebook (see {numref}`chart:olab-notebook-unique-users`) shows a distinct pattern; nearly all users visited the index page (those who didn't likely experienced connectivity problems), with the most popular experiment being the NaI(Tl) detector investigation notebook (`10-nai-detector.ipynb`). Besides this experiment, the majority of the virtual experiments had similar occupancy, with the detector comparison notebook (`60-detector-comparison.ipynb`) being the least popular of the available assignments.

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The number of notebook sessions that users opened during the trial.
    name: chart:olab-notebook-sessions
tags: [hide-input]
---
(
    alt.Chart(df_count_by_user)
    .mark_bar()
    .encode(alt.X("notebook", bin=alt.BinParams(step=1)), y="count()")
    .interactive()
)
```

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The number of unique-notebook sessions that users opened during the trial.
    name: chart:olab-unique-notebook-sessions
tags: [hide-input]
---
(
    alt.Chart(df_unique_count_by_user)
    .mark_bar()
    .encode(alt.X("notebook", bin=alt.BinParams(step=1)), y="count()")
    .interactive()
)
```

```{code-cell} ipython3
---
mystnb:
  figure:
    caption: The number of users that opened each notebook at least once during the
      trial. Anonymous user IDs were generated by hashing the unique Canvas student
      IDs.
    name: chart:olab-notebook-unique-users
tags: [hide-input]
---
(
    alt.Chart(df_unique_count_by_notebook)
    .mark_bar()
    .encode(alt.Y("notebook"), alt.X("user"))
    .interactive()
)
```
